\documentclass[11pt]{article}
\usepackage[letterpaper]{geometry}

%Used to split pages into two columns, IE the truth tables
\usepackage{multicol}

%Used to place figures
\usepackage{graphicx}
\usepackage{float}

%Used so that multi-line caption text is centered instead of left-aligned
\usepackage[center]{caption}

%Used to squish TOC
\usepackage{setspace}

%Used to show code nicely formatted
\usepackage{listings}
\usepackage{color}

%Used for Showing Mathematical Proofs
\usepackage{amsmath,amsthm,amssymb}

%Used for tables
\usepackage{array}
\usepackage{booktabs}

%Used for canceling terms in Math
\usepackage{cancel}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

%Used to include the signatures sheet
\usepackage{pdfpages}

\title{EENG490\linebreak \linebreak Integrated Oscilloscope/Logic Analyzer/Signal Generator}
\author{Jeremy Munson, Braeden Bryant}
\geometry{top=.8in, bottom=.8in, left=.8in, right=.8in}

\setlength{\parindent}{0em}
\setlength{\parskip}{.5em}
\setlength{\floatsep}{-20px}
\setlength{\textfloatsep}{-20px}

\begin{document}
	
	\input{cover_sheet.tex}
	\input{tables.tex}
	\input{abstract.tex}

	\section{Proposal}
	\input{proposal.introduction.tex}
	\input{proposal.motivation.tex}
	\input{proposal.constraints.tex}
	\input{proposal.schedule.tex}
	\input{proposal.costs.tex}
	\input{proposal.deliverables.tex}
	\input{proposal.conclusion.tex}

	\section{Team Organization}
	\input{team.background.tex}
	\input{team.responsibilities.tex}

	\section{Initial Research}
	\input{research_initial.project_feasibility.tex}
	\input{research_initial.similar_products.tex}

	\section{Project Overview}
	\input{project.design_criteria.tex}
	\input{project.architectural_overview.tex}
	\input{project.architecture_block_diagram.tex}
	\input{project.block_solutions_interfaces.tex}

	\section{Research of Proposed Solutions}
	\input{research.ADC.tex}
	\input{research.signal_generator.tex}
	\input{research.USB_interface.tex}
	\input{research.FPGA.tex}
	\input{research.STM32.tex}
	\input{research.power_supply.tex}
	\input{research.breadboard_unit.tex}



	\section{


	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.8\linewidth]{adcdac_timing}
		\caption{ADC/DAC Follower experiment with single triangle input demonstrating timing characteristics.}
		\label{fig:adcdactiming}
		\vspace{20px}
	\end{figure}
	
	The time shift between a particular value on the input (blue) waveform and the DAC output (red) waveform was measured as $\approx 4\mu s$. This is the 'miniscule' distance between the two waveforms at marker (1) on Figure (1). This means that performing the ADC conversion then outputting the value on the DAC pin only took that long. Unfortunately, Micropython had a much larger delay: the time between markers (1) and (2) on the figure. This delay is $\approx 65 \mu s$. Some significant research revealed the cause: when using the pyb.ADC.read() method the entire ADC peripheral is shut off then restarted between uses - from turning off the pins to shutting down the ADC clock!\footnote{https://forum.micropython.org/viewtopic.php?t=610 - See the post by Damien - a micropython developer - on Mar 23, 2015.}$^{,}$\footnote{\label{ADCsource}Also see the ADC object source code at https://github.com/micropython/micropython/blob/master/ports/stm32/adc.c where all this is clearly evident.} Then the peripheral is restarted, including waiting for newly turned on clocks to stabilize, working all the way from "MCU just turned on" forward. This large delay effectively limits sampling to a rate to $~15kHz$, which makes examining signals with components faster than $7.5kHz$ impossible according to Nyquist's Theorem. As a practical matter, a minimum sample rate of 5x-10x the desired frequency is usually required, which limits us to signals of $2kHz$ or less.
	
	\subsection{Waveform Timed Capture + Storage}
	This experiment gets away from the issues with ADC.read() by using ADC.read\_timed(). ADC.read\_timed() captures samples at set intervals (according to a timer) using C. This results in usable sample rates up to around 700$kHz$. The entire recorded sample buffer is then output on the DAC at the same sample rate. The ADC.read\_timed() method blocks until the buffer is completely filled, so we are unable to output the readings immediately. Additionally, this blocking time might be significant, preventing the execution of other code.
	\subsubsection{Still limited} Being done in C, ADC.read\_timed() is much faster. Unfortunately, this is implemented in C by using busy-waiting on timer values(not callback interrupts), stopping when the timer is high enough. After stopping the code calculates positions in the buffer array from the python type (among several other operations) before finally storing the reading. As a result, the $2.4Msps/8.2Msps$(interleaved) capability of the microcontroller simply can't be reached. Also, there is a delay in each sample time where the timer isn't running, causing samples to occur slower than they should, resulting in a time-scaled signal reading. The correct way to read these samples would be to use a DMA peripheral.
	
	\subsection{ADC Accuracy Experiment}
	This experiment periodically takes readings of the voltage on pin X12 and the internal reference voltage, then prints out the read value, a weighted average of read values, and the voltage reference value. The ADCAll object is used, which initializes ADC functionality on all compatible pins and channels.
	
	\section{Lessons Learned}
	\subsection{Discreet sampling levels}
	When we take a sample with the ADC, the result is a discreet level. The precision is configurable and can be set up to 12 bits, yielding 4096 discreet levels. When using ADC or DAC peripherals, this needs to be taken into account. This limitation could also be seen in the Tektronix Oscilloscope's signal generator, which is also just a DAC. Figure (\ref{fig:discreet1}) demonstrates what this looks like mathematically using a graph.
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.8\linewidth]{discreet1}
		\caption{Plot comparing discreet levels of a sine wave, graph. Sample value vs time.}
		\label{fig:discreet1}
		\vspace{25px}
	\end{figure}
	
	\subsection{Discreet Sampling Times}
	Similar to the discreet voltage levels that can be read, samples are also done at a limited rate and only give us the voltage at the brief instant the analog capture buffer performs the sample. The capture and hold buffer is an analog device - many digital clock cycles after this initial capture are needed to actually perform the conversion. This gives no indication of what values the signal assumed in-between captures and causes signal aliasing. Figures (\ref{fig:adcdactiming}, \ref{fig:aliasing1}, and \ref{fig:aliasing2}) all show sampling done at a discreet, relatively slow rate. The "poor" signal recreation in each of those figures is dominated by the very slow sample rate relative to the signal.
	
	\subsection{Signal Aliasing}
	When sampling a signal, aliases are created in the frequency domain, related to the sampling rate. If the sampling rate is less than 2x the highest frequency in the signal then the aliases will overlap the original signal. This causes distortion of the signal. Without going too deep into EENG320/321 topics - half the frequency domain components from two of the aliases can appear to create a signal at a \textbf{lower} frequency that than the original signal. In the time domain this appears like this: Given a signal period T, take samples at $t=T, t=2T+AT, t=3T+2AT, t=4T+3AT...$ where A is some fraction of T (such as T/10) then interpolate between the points taken - a signal the same shape, but wrong frequency will be seen. This is demonstrated in Figure (\ref{fig:aliasing1}) using an input of train of triangular pulses.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{aliasing}
		\caption{A particular case of aliasing. The input(blue) signal is a train of triangular pulses followed by a dead-time the same length as the pulse. The signal reconstructed from samples, red, takes the same shape as the original signal but at a much lower frequency.}
		\label{fig:aliasing1}
		\vspace{15px}
	\end{figure}
	
	This particular case of aliasing due to insufficient sample rate isn't the only possible result. Usually the mixing of frequency components results in a signal that is composed of many aliases overlapped, such as in Figure (\ref{fig:aliasing2}) where multiple aliases of the original signal can be seen.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{aliasing2}
		\caption{The input(blue) signal is a train of triangular pulses. The signal reconstructed from samples, red, shows several frequency scaled aliases of the signal overlapping.}
		\label{fig:aliasing2}
		\vspace{15px}
	\end{figure}
	
	\subsection{ADC input impedance/current, signal distortion.}
	When an ADC sample is taken, the analog sample and hold buffer circuit is connected to the ADC. This circuit has an effective impedance to ground between $50k\Omega$ and $6k\Omega$ depending on the sampling rate.\footnote{https://www.st.com/resource/en/datasheet/dm00037051.pdf | Section 15.3.21 (ADC Characteristics)} When the input signal is even moderately high impedance, say $10k\Omega$, the voltage level will drop significantly. When doing additional work on the lab at home on my own home-made signal generator (which has an impedance of $50\Omega$ and a swing of $\pm 15v$) the Pyboard ADC input was connected through a $150k\Omega$ resistor, to protect the Pyboard. This immediately made the impedance characteristics of the ADC apparent. I performed a simulation, adjusting values of equivalent ADC impedance and parasitic capacitance until figure \ref{fig:adc_impedance} was produced, which matches quite closely with what was observed.
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{adc_impedance}
		\caption{Calculated plot of signal distortion caused by high ADC input current relative to signal impedance.}
		\label{fig:adc_impedance}
		\vspace{15px}
	\end{figure}
	This is of \textbf{enormous} importance when using the ADC peripheral - if a signal is from a high impedance source, such as a passive sensor, then this absolutely must be accounted for. Depending on the relative impedance, simple calibration might be enough; otherwise a separate analog input buffer (opamp) will be needed.
	
	\subsection{Signal Clipping}
	The ADC peripheral determines the voltage by comparing it to the external ADC reference voltage. Nominally this is 3.3 volts. The reference voltage is divided into (up to) 4096 discreet voltage levels between 0v and the reference, then the conversion performed. The analog electronics that perform the conversion have no way to operate on voltages outside the reference range. Instead the peripherals see anything below ground level as 0 and anything above the reference as the maximum value. As a result, any part of a signal outside this range will be "clipped" or "clamped". Figure (\ref{fig:adc_clipping}) shows a plot of what this would look like with a $4\cdot sin(t)$ input into a device with a range of $0v$-$3.3v$. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{clipping}
		\caption{Calculated plot of signal clipping. Measured signal(black), vs input(grey)}
		\label{fig:adc_clipping}
		\vspace{15px}
	\end{figure}
	
	As a practical matter, testing signal clipping was limited to high impedance signals to protect the Pyboard. See the ADC input impedance section on why this causes some issues. 
	
	\subsection{Garbage Collector}
	The python garbage collector ordinarily runs at indeterminate times during the program execution. Running the garbage collector is an expensive operation - so expensive that even on modern high performance desktop computers it can be a problem for timing. Running a garbage collector randomly in an embedded system guarantees that eventually the timing of something will be wrong. Due to this, I have disabled the garbage collector before each timing-critical section of code.
	In each experiment, code similar to the following was used when appropriate:
	\begin{lstlisting}[language=Python]
		gc.collect()
		gc.disable()
		while condition:
		do_something()
		gc.enable()
	\end{lstlisting}
	Where the while loop may run for a very long time on a memory constrained system. Each read of the ADC creates and returns a new object. Surely, eventually, this will consume all the available system memory? It is unwise to make absolute statements about a large complex piece of software like the micropython interpreter; however after some research I believe this is okay. 
	Python has two types of memory management behind the scenes: The cyclic garbage collector which runs periodically by "stopping the world" and checking to see what objects are still in use and reference counting. gc.disable() turns off the cyclic garbage collector, but not reference counting. 
	Reference counting is used for short-lived objects - like an unnamed return value from a function. Once the reference count drops to 0 the object is immediately collected. I tested this using micropython.mem\_info() etc, and in our case we will not accumulate garbage while the loop is running. This is a weak guarantee and relies on implementation defined behavior; if the system is performance critical than use something other than python to program it. Python will never provide the guarantees needed for timing critical systems.
	
	\subsection{Array and impact on execution time}
	The Micropython array, as opposed to a python list, operates more quickly and can interoperate with ADC.read\_timed(). Overall choosing an array over a list results in marginally faster ADC conversions. ADC conversion time is dominated by the poorly performant code in the micropython ADC objects and methods.
	
	\subsection{ADC Accuracy}
	The ADC Accuracy experiment showed that the final few bits of the ADC reading varied greatly. Overall the reading was stable to about $\pm0.01V$ which is sufficient for most uses. If more accuracy was needed then the circuit design around the STM32F405 would need to reflect that - separate analog ground, careful PCB trace routing away from digital traces, a precision ADC reference voltage with good decoupling, and possibly even EMI shielding. The Pyboard doesn't do any of these things - using the main 3.3V supply for reference, sharing grounds, and all the traces are general purpose so have no significant isolation. That said, this is fine for most purposes. 
	
	There was one strange issue that occurred: the ADC reference voltage from the ADCAll.read\_vref() method seemed to be off by as much as $\pm60mV$, and off by a different amount every time the Pyboard restarted. That is, on one restart it might read values in the range of $3.245V - 3.253V$, then read values in the range of $3.315V - 3.323V$ after restarting the board. Digging around the Micropython source code\footnote{https://github.com/micropython/micropython/blob/master/ports/stm32/adc.c} revealed that \textbf{an initial reference voltage reading is done on the Pyboard startup, then used to interpret all future vref readings!} By taking a reading at startup, when many things are happening (peripherals turning on, etc) it seems that the reference voltage (which is just the main supply) fluctuates when the reading is taken. This makes the ADCAll.read\_vref() method absolutely useless, and in fact detrimental, for improving the accuracy of ADC readings on the Pyboard with micropython. If we were programming the device in C then we would just properly take a reading of the reference ourselves instead of relying on the questionable quality micropython library.
	
	\section{Lab Feedback}
	\subsection{What would you do if you had more time?}
	I spent quite a bit of time exploring other things. I have the advantage of owning a significant amount of electrical test equipment, so spent as much time experimenting with the Pyboard as I felt like. While "Doing so much extra shows your boss that you don't have enough work", this is an educational exercise so I considered doing extra to be a valuable learning experience. Also, I quite enjoy embedded systems so wanted to spend the extra effort exploring. (That and I was between exams in my other classes, so had some time.)
	
	\subsection{Did you enjoy this project or not. Why?}
	The lab was enjoyable. I learned a lot about ADCs and DACs. My disdain for Micropython grew greatly after exploring the underlying code - it is worse software than the Arduino libraries.
	
	\subsection{Suggestions to improve the lab}
	After observing the other students: The first week needs some concrete deliverables so that students don't think "Oh, I can do it next week" and not finish anything the first week. I'm torn between saying "Student Responsibility" and "It's a 100 level course". 
	
	I would also suggest assigning a homework prior to the lab: write some ADC code and test it in the Pyboard emulator: https://micropython.org/unicorn/ before the lab. That way students spend time in the lab working with the actual equipment instead of trying to write code under pressure. It is my experience at EWU that the *current* batch of seniors are completely incapable of using an oscilloscope well. Students need more time in front of actual equipment. They can code any time at home.
	
	Next, students should spend time with the pyboard at home. The PWM part of the project is meant to give us a signal to look at, but there is a much better method available: pyb.DAC.triangle() that will output a 12-bit accurate triangle wave. Students can use this as a test signal instead of the PWM, since it takes on analog values.
	
	Finally, home experimentation (and the course) could benefit from using a logic analyzer. There are cheap ($<$\$10) logic analyzers that can be used with free software (Saleae's software is free, or SIGROK is GNU GPL) at home when most students don't have an oscilloscope. Logic analyzers are cheaper and harder to damage than the Pyboards. Use of the software is pretty automatic (Sigrok automatically detects all supported logic analyzers) and a useful skill.
	
	\section{Conclusion}
	Overall, the lab gave me a strong jumping off point to do a deep-dive into the STM32 ADC peripherals and how Micropython is implemented. I learned a lot about ADCs (which I had only ever used blindly, before) and found a lot of material to argue against Micropython, should anyone ever suggest it for a professional project that isn't a 5 minute prototype. The lab was enjoyable and a good experience. 
\end{document}
